require('dotenv').config();
const Airtable = require('airtable');

// --- CONFIGURATION ---
const AIRTABLE_BASE_ID = process.env.AIRTABLE_BASE_ID;
const AIRTABLE_PAT = process.env.AIRTABLE_PAT;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const TABLE_NAME = 'Projects';

// Initialize Airtable
const base = new Airtable({ apiKey: AIRTABLE_PAT }).base(AIRTABLE_BASE_ID);

// Strict system instructions for the AI
const SYSTEM_PROMPT = `
You are a data-mining assistant for 30x30 UK. 
Given a location Name and URL, research it and return a strict JSON object with NO markdown formatting, NO backticks, just raw JSON.
Schema:
{
  "Description": "180-220 characters. Plain UK English. Present tense. Strictly factual, no marketing fluff.",
  "Lat": 0.00000, 
  "Long": 0.00000,
  "Region": "MUST BE EXACTLY ONE OF: Yorkshire & Humber, South East England, Scotland, Northern Ireland, West Midlands, Wales, East Midlands, North East England, East of England, London, South West England, North West England",
  "HostOrg": "The main operating organisation",
  "Type": "Array of strings. Include 'Volunteering' if the site mentions volunteering opportunities. Include 'Fundraising' if the site mentions donations, fundraising, or appeals. Can contain both, one, or be empty []."
}
Coordinates MUST be precise to 5 decimal places. Do not invent data if unsure.
`;

/**
 * Communicates with Gemini API
 */
async function enrichLocation(name, url) {
    const prompt = `Location Name: ${name}\nURL: ${url}\nGenerate the JSON.`;
    
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] },
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json" }
            })
        });

        const data = await response.json();
        
        if (data.error) {
            throw new Error(`Google API Error: ${data.error.message}`);
        }
        
        if (!data.candidates || data.candidates.length === 0) {
            throw new Error("No response generated by AI.");
        }

        const jsonString = data.candidates[0].content.parts[0].text;
        return JSON.parse(jsonString);

    } catch (error) {
        console.error(`\nâŒ AI Research failed for "${name}": ${error.message}`);
        return null;
    }
}

/**
 * Main loop: Fetches, enriches, and updates until no records remain.
 */
async function runPipeline() {
    console.log("ðŸš€ Starting 30x30 UK Enrichment Pipeline (Automated Loop Mode)...");
    console.log("Using Gemini Paid Tier (High RPM) and Airtable (5 RPS Limit).");

    let hasMore = true;
    let consecutiveErrorCount = 0;

    while (hasMore) {
        try {
            // Fetch next batch of records where Description is empty and not published
            const records = await base(TABLE_NAME).select({
                filterByFormula: "AND(NOT({Published}), {Description} = '')",
                maxRecords: 100 
            }).firstPage();

            if (!records || records.length === 0) {
                console.log("\n\nâœ… All done! No more pending records found in Projects.");
                hasMore = false;
                break;
            }

            console.log(`\nðŸ“¦ Processing batch of ${records.length} records...`);

            for (const record of records) {
                const name = record.get('Name');
                const url = record.get('LocationURL');

                if (!name || !url) {
                    process.stdout.write("s"); // 's' for skipped
                    continue;
                }

                const enrichedData = await enrichLocation(name, url);

                if (enrichedData) {
                    try {
                        let updateFields = {
                            "Description": enrichedData.Description,
                            "Lat": enrichedData.Lat,
                            "Long": enrichedData.Long,
                            "Region": enrichedData.Region,
                            "HostOrg": enrichedData.HostOrg
                        };

                        if (Array.isArray(enrichedData.Type) && enrichedData.Type.length > 0) {
                            updateFields["Type"] = enrichedData.Type;
                        }

                        // Update back to Airtable
                        await base(TABLE_NAME).update(record.id, updateFields, { typecast: true });
                        
                        // Success indicator
                        process.stdout.write("."); 
                        consecutiveErrorCount = 0;

                    } catch (airtableErr) {
                        console.log(`\n\nâŒ Airtable Write Failed for "${name}"`);
                        console.log("ðŸ› ï¸ FAILED DATA OBJECT:", JSON.stringify(enrichedData, null, 2));
                        console.error("REASON:", airtableErr.message);
                    }
                }
                
                // 250ms pause = 4 updates per second. Airtable limit is 5.
                await new Promise(res => setTimeout(res, 250)); 
            }

        } catch (err) {
            console.error("\n\nâŒ Critical Batch Error:", err.message);
            consecutiveErrorCount++;
            
            if (consecutiveErrorCount >= 3) {
                console.log("ðŸ›‘ 3 consecutive errors encountered. Killing script for safety.");
                hasMore = false;
            } else {
                console.log("ðŸ”„ Waiting 10s before retry...");
                await new Promise(res => setTimeout(res, 10000));
            }
        }
    }
}

// Kick off the engine
runPipeline();